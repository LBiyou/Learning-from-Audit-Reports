// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {GenerateExceptions} from "./GenerateExceptions.sol";

interface IGenerateExceptions {
    function instant_NonExistentAddress() external;

    // Wrongly adding return value to the interface
    function returnDataNotMatchInterface1() external returns (uint256);

    // Without return value
    function returnDataNotMatchInterface2() external;

    /** Test (bool, address, bytes32, bytes, string) => uint256
      * <all these functions returns uint256>
      * function returnAddress() external pure returns (uint256);
        function returnBool() external pure returns (uint256);
        function returnUint256() external pure returns (uint256);
        function returnBytes32() external pure returns (uint256);
        function returnBytes() external pure returns (uint256); // error
        function returnString() external pure returns (uint256); // No error!!!
     */

    /** Test (bool, address, bytes32, bytes, string) => address
     *  <all these functions returns address>
     *  function returnAddress() external pure returns (address);
        function returnBool() external pure returns (address);
        function returnUint256() external pure returns (address);
        function returnBytes32() external pure returns (address);
        function returnBytes() external pure returns (address); // error
        function returnString() external pure returns (address); // No error!!!
     */
    function returnAddress() external pure returns (address);

    function returnBool() external pure returns (address);

    function returnUint256() external pure returns (address);

    function returnBytes32() external pure returns (address);

    function returnBytes() external pure returns (address, address);

    function returnString() external pure returns (address);
}

contract CatchException {
    event ExceptionCaught(string _exception);
    event ExceptionNotCaught(string _message);
    event OtherExceptionCaught(bytes _error);
    event PanicError(uint256, string);
    event CatchError(string, string);

    function catch_Instant_NonExistentAddress(address _ge) external {
        try IGenerateExceptions(_ge).instant_NonExistentAddress() {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch Instant_NonExistentAddressError");
        }
    }

    function catch_ReturnDataNotMatchInterface1(address _ge) external {
        try IGenerateExceptions(_ge).returnDataNotMatchInterface1() {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnDataNotMatchInterfaceError");
        }
    }

    function catch_ReturnDataNotMatchInterface2(address _ge) external {
        try IGenerateExceptions(_ge).returnDataNotMatchInterface2() {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnDataNotMatchInterfaceError");
        }
    }

    function catch_ReturnAddress(address _ge) external {
        try IGenerateExceptions(_ge).returnAddress() returns (address) {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnAddressError");
        }
    }

    function catch_ReturnBool(address _ge) external {
        try IGenerateExceptions(_ge).returnBool() returns (address) {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnAddressError");
        }
    }

    function catch_ReturnUint256(address _ge) external {
        try IGenerateExceptions(_ge).returnUint256() returns (address) {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnAddressError");
        }
    }

    function catch_ReturnBytes32(address _ge) external {
        try IGenerateExceptions(_ge).returnBytes32() returns (address) {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnAddressError");
        }
    }

    function catch_ReturnBytes(address _ge) external {
        try IGenerateExceptions(_ge).returnBytes() returns (address, address) {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnBytesError");
        }
    }

    //
    function catch_ReturnString(address _ge) external {
        try IGenerateExceptions(_ge).returnString() returns (address) {
            emit ExceptionNotCaught("Exception not caught");
        } catch {
            emit ExceptionCaught("catch ReturnBytesError");
        }
    }

    function catch_OtherErrors(address _ge) external {
        /**
         * 1. GenerateExceptions(_ge).requireError => emit CatchError(: "require error", : "Catch Error")
         * 2. GenerateExceptions(_ge).revertError() => emit CatchError(: "revert error", : "Catch Error")
         * 3. GenerateExceptions(_ge).outOfGas() => emit OtherExceptionCaught(_error: 0x)
         * 4. GenerateExceptions(_ge).divisionByZero() => emit PanicError(: 18, : "Panic error caught")
         * 5. GenerateExceptions(_ge).assertError()   =>  emit PanicError(: 1, : "Panic error caught")
         * 6. GenerateExceptions(_ge).invalidArrayAccess() => emit PanicError(: 50, : "Panic error caught")
         * 7. GenerateExceptions(_ge).arithmeticOverflow() => emit PanicError(: 17, : "Panic error caught")
         *
         * In conclusion:
         * Catch Error(string memory): Can catch the above seven exception except outOfGas.
         * Panic Error(uint256): Can catch the above seven exception except requireError, revertError and outOfGas.
         * Catch Error(bytes memory): Can catch the above seven exception.
         *
         * If these three ways of catching exceptions are declared at the same time:
         * catch (bytes memory) will catch: outOfGas
         * catch Panic(uint256) will catch: divisionByZero, assertError, invalidArrayAccess, arithmeticOverflow
         * catch Error(string memory) will catch: requireError, revertError
         */
        try GenerateExceptions(_ge).arithmeticOverflow() {
            emit ExceptionNotCaught("Exception not caught");
        } catch (bytes memory _error) {
            emit OtherExceptionCaught(_error);
        } catch Panic(uint256 errorCode) {
            emit PanicError(errorCode, "Panic error caught");
        } catch Error(string memory _error) {
            emit CatchError(_error, "Catch Error");
        }
    }
}
