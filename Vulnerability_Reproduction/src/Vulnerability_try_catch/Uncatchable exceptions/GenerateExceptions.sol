// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract GenerateExceptions {
    /** Exceptions that cannot be caught by try/catch */

    ////////////////////////// case1 /////////////////////////////
    /// @dev Calling a function at a null address will not catch this error.
    function instant_NonExistentAddress() external {}

    ////////////////////////// case2 /////////////////////////////
    /// @dev Does not return a value of the specified type according to the interface.
    /// @notice The function actually has no return value, but it is declared in the interface that the function has a return value
    function returnDataNotMatchInterface1() external {}

    // There is a return value in the function but not in the interface
    function returnDataNotMatchInterface2() external pure returns (uint256) {
        return 1;
    } 

    /**
     * Details about return value mismatch.
     */
    function returnAddress() external pure returns (address) {
        return
            address(uint160(uint256(keccak256(abi.encodePacked("address")))));
    }

    function returnBool() external pure returns (bool) {
        return false;
    }

    function returnUint256() external pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked("uint256")));
    }

    function returnBytes32() external pure returns (bytes32) {
        // bytes32(uint256(uint160(uint256(keccak256(abi.encodePacked("bytes32")))))); // No error
        return keccak256(abi.encodePacked("bytes32"));
    }

    function returnBytes() external pure returns (bytes memory) {
        return "bytes";
    }

    function returnString() external pure returns (string memory) {
        return "stringstringstringstringstringstringstring";
    }

    /**
     * Exceptions that cannot be caught by try/catch
     * Common error types:
     * 1. require()
     * 2. assert()
     * 3. revert()
     * 4. division by zero
     * 5. out of gas
     * 6. invalid array access
     * 7. arithmetic overflow
     * 8. and so on...
     */

    function requireError() external pure {
        require(false, "require error");
    }

    function assertError() external pure {
        assert(false);
    }

    function revertError() external pure {
        revert("revert error");
    }

    function divisionByZero() external pure {
        uint256 a = 1;
        uint256 b = 0;
        uint256 c = a / b;
    }

    uint256 public toWrite;

    function outOfGas() external {
        for (uint256 i = 0; ; i++) {
            toWrite = i;
        }
    }

    function invalidArrayAccess() external pure {
        uint256[] memory arr = new uint256[](3);
        arr[3] = 1;
    }

    function arithmeticOverflow() external pure {
        uint256 a = type(uint256).max;
        uint256 b = 1;
        uint256 c = a + b;
    }
}
